import math

def Merge(A, p, q, r):                      # Принимаем параметры: сортируемый массив, точка начала, середина, точка конца
    n1 = q - p + 1                          # Длина левой части
    n2 = r - q                              # Длина правой части
    L = []                                  # Создаём пустую левую часть
    R = []                                  # Создаём пустую правую часть
    for i in range(0, n1):                  # Заполняем левую часть левой частью сортируемого массива
        L.append(A[p + i - 1])              #
    for j in range(0, n2):                  # Заполняем правую часть правой частью сортируемого массива
        R.append(A[q + j])                  #
    L.append([math.inf, math.inf])          # Добавляем ещё один элемент что бы не выйти за границы массива при объединении массивов в один
    R.append([math.inf, math.inf])          # Добавляем ещё один элемент что бы не выйти за границы массива при объединении массивов в один
    i = 0                                   # Инициализируем итератор для левой части
    j = 0                                   # Инициализируем итератор для правой части
    for k in range(p - 1, r):               # Объединяем два массива в один, сортируем
        if L[i][1] <= R[j][1]:              # Если текущий элемент левой части меньше или равен текущему элементу правой
            A[k] = L[i]                     # Вставляем текущий элемент левой части
            i += 1                          # Увеличиваем итератор левой части
        else:                               # Иначе если текущий элемент левой части больше текущего элемента правой
            A[k] = R[j]                     # Вставляем текущий элемент правой части
            j += 1                          # Увеличиваем итератор правой части

def MergeSortBySecond(A, p, r):             # Принимаем параметры: сортируемый массив, точка начала, точка конца
    if p < r:                               # Если точка начала меньше точки конца
        q = math.floor((p + r) / 2)         # Вычисляем середину массива округлённую вниз
        MergeSortBySecond(A, p, q)          # Рекурсивно вызываем эту функцию для левой части сортируемого массива
        MergeSortBySecond(A, q + 1, r)      # Рекурсивно вызываем эту функцию для правой части сортируемого массива
        Merge(A, p, q, r)                   # Вызываем процедуру слияния

def MergeInvCount(A, p, q, r):              # Принимаем параметры: сортируемый массив, точка начала, середина, точка конца
    n1 = q - p + 1                          # Длина левой части
    n2 = r - q                              # Длина правой части
    L = [math.inf for i in range(n1 + 1)]   # Создаём пустую левую часть
    R = [math.inf for i in range(n2 + 1)]   # Создаём пустую правую часть
    for i in range(0, n1):                  # Заполняем левую часть левой частью сортируемого массива
        L[i] = A[p + i - 1]                 #
    for j in range(0, n2):                  # Заполняем правую часть правой частью сортируемого массива
        R[j] = A[q + j]                     #
    i = 0                                   # Инициализируем итератор для левой части
    j = 0                                   # Инициализируем итератор для правой части
    counter = 0                             # Инициализируем счётчик инверсий
    for k in range(p - 1, r):               # Объединяем два массива в один, сортируем                                  
        if L[i] <= R[j]:                    # Если текущий элемент левой части меньше или равен текущему элементу правой
            A[k] = L[i]                     # Вставляем текущий элемент левой части                                     
            i += 1                          # Увеличиваем итератор левой части
        else:                               # Иначе если текущий элемент левой части больше текущего элемента правой    
            A[k] = R[j]                     # Вставляем текущий элемент правой части                                    
            j += 1                          # Увеличиваем итератор правой части                                         
            counter += n1 - i               # Количество инверсий на каждом этапе merge равно оставшемуся количеству элементов в левой части
    return counter                          # Возвращаем количество итераций

def InvCount(A, p, r):                      # Принимаем параметры: сортируемый массив, точка начала, точка конца
    if p < r:                               # Если точка начала меньше точки конца
        q = math.floor((p + r) / 2)         # Вычисляем середину массива округлённую вниз
        x = InvCount(A, p, q)               # Рекурсивно вызываем эту функцию для левой части сортируемого массива, получаем количество левых итераций
        y = InvCount(A, q + 1, r)           # Рекурсивно вызываем эту функцию для правой части сортируемого массива, получаем количество правых итераций
        z = MergeInvCount(A, p, q, r)       # Вызываем процедуру слияния, получаем количество разделённых итераций
        return x + y + z                    # Возвращаем общее количество итераций
    else:                                   # Иначе если точка начала больше или равна точке конца
        return 0                            # Возвращаем 0

def sortToCount(arr1, arr2):                # Принимаем параметры: массив индексов для результирующего массива, массив значений для перестановки
    temp = arr1.copy()                      # Копируем исходный массив индексов в новый временный
    for i in range (len(arr1)):             # Проходимся по всему массиву индексов
        temp[arr1[i] - 1] = arr2[i]         # Во временный массив на элемент с индексом соответствующим текущему элементу массива индексов ставим текущий элемент массива значений
    return temp                             # Возвращаем полученный массив